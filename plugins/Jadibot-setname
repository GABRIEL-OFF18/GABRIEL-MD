// Lista de tokens premium válidos
const premiumTokens = Array.from({ length: 10 }, (_, i) => `MAK${i + 1}`);

// Guardado global de tokens usados (persistente si usas una db)
global.usedPremiumTokens = global.usedPremiumTokens || {};

const { useMultiFileAuthState, fetchLatestBaileysVersion, makeCacheableSignalKeyStore } = await import("@whiskeysockets/baileys");
import qrcode from "qrcode";
import NodeCache from "node-cache";
import fs from "fs";
import path from "path";
import pino from 'pino';
import * as ws from 'ws';
import { makeWASocket } from '../lib/simple.js';
import { fileURLToPath } from 'url';

// Mensajes premium
const rtx = "*︰꯭𞋭🩵 ̸̷᮫໊᷐͢᷍ᰍ⧽͓̽ CONEXIÓN PREMIUM*\n\n━⧽ MODO CODIGO QR PREMIUM\n\n✰ Pasos de vinculación:\n\n• Escanea este QR en WhatsApp Web.\n• Disfruta de tu SubBot premium.";
const rtx2 = "*︰꯭𞋭🩵 ̸̷᮫໊᷐͢᷍ᰍ⧽͓̽ CONEXIÓN PREMIUM*\n\n━⧽ MODO CODIGO PREMIUM\n\n✰ Pasos de vinculación:\n\n• Pega este código en WhatsApp Web.\n• Disfruta de tu SubBot premium.";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let handler = async (m, { conn, args, usedPrefix, command }) => {
  // Solo acepta codepremium y qrpremium
  if (!['codepremium', 'qrpremium'].includes(command)) return;

  // Control de spam
  let time = global.db.data.users[m.sender].Subs + 120000;
  if (new Date - global.db.data.users[m.sender].Subs < 120000)
    return conn.reply(m.chat, `🕐 Debes esperar ${msToTime(time - new Date())} para volver a vincular un *Sub-Bot Premium.*`, m);

  // Si no hay argumento/token
  if (!args[0]) return conn.reply(m.chat, "Ingresa un token", m);

  const token = args[0].trim().toUpperCase();

  // Token no válido
  if (!premiumTokens.includes(token))
    return conn.reply(m.chat, "Este token no está en mi base de datos", m);

  // Token ya usado
  if (global.usedPremiumTokens[token])
    return conn.reply(m.chat, "Este token ya está ocupado, ingresa un token válido", m);

  // Marcar token como usado
  global.usedPremiumTokens[token] = m.sender;

  // Token correcto
  await conn.reply(m.chat, "Token correcto enviando vinculación", m);

  // Lógica de sesión premium (idéntica a subbot, pero aislada)
  let id = `${m.sender.split`@`[0]}`;
  let pathPremium = path.join(`./premiumSessions/`, id);
  if (!fs.existsSync(pathPremium)) fs.mkdirSync(pathPremium, { recursive: true });

  // Si es codepremium, genera código de vinculación
  if (command === 'codepremium') {
    await blackPremium({
      pathPremium, m, conn, codeMode: true
    });
  }
  // Si es qrpremium, genera QR
  if (command === 'qrpremium') {
    await blackPremium({
      pathPremium, m, conn, codeMode: false
    });
  }

  global.db.data.users[m.sender].Subs = new Date * 1;
};
handler.help = ['qrpremium <TOKEN>', 'codepremium <TOKEN>'];
handler.tags = ['premium'];
handler.command = ['qrpremium', 'codepremium'];
export default handler;

// Función principal para vinculación premium
async function blackPremium({ pathPremium, m, conn, codeMode }) {
  // ---- Configuración de sesión
  const { version } = await fetchLatestBaileysVersion();
  const msgRetryCache = new NodeCache();
  const { state, saveState, saveCreds } = await useMultiFileAuthState(pathPremium);

  const connectionOptions = {
    logger: pino({ level: "fatal" }),
    printQRInTerminal: false,
    auth: {
      creds: state.creds,
      keys: makeCacheableSignalKeyStore(state.keys, pino({ level: 'silent' }))
    },
    msgRetry: () => {},
    msgRetryCache,
    browser: codeMode ? ['Ubuntu', 'Chrome', '110.0.5585.95'] : ['Makima Premium', 'Chrome', '2.0.0'],
    version: version,
    generateHighQualityLinkPreview: true
  };

  let sock = makeWASocket(connectionOptions);

  sock.ev.on('connection.update', async (update) => {
    const { connection, isNewLogin, qr } = update;
    if (connection === 'open') {
      await conn.sendMessage(m.chat, { text: `@${m.sender.split('@')[0]}, Te conectaste a Makima Premium con éxito.`, mentions: [m.sender] }, { quoted: m });
      global.conns.push(sock);
    }
    if (qr && !codeMode) {
      // QR Premium
      let txtQR = await conn.sendMessage(m.chat, { image: await qrcode.toBuffer(qr, { scale: 8 }), caption: rtx }, { quoted: m });
      if (txtQR && txtQR.key) setTimeout(() => { conn.sendMessage(m.sender, { delete: txtQR.key }) }, 30000);
    }
    if (qr && codeMode) {
      // Código Premium
      let secret = await sock.requestPairingCode((m.sender.split`@`[0]));
      secret = secret.match(/.{1,4}/g)?.join("-");
      let txtCode = await conn.sendMessage(m.chat, { text: rtx2 }, { quoted: m });
      let codeBot = await m.reply(secret);
      if (txtCode && txtCode.key) setTimeout(() => { conn.sendMessage(m.sender, { delete: txtCode.key }) }, 30000);
      if (codeBot && codeBot.key) setTimeout(() => { conn.sendMessage(m.sender, { delete: codeBot.key }) }, 30000);
    }
  });

  // Limpieza automática
  setInterval(async () => {
    if (!sock.user) {
      try { sock.ws.close(); } catch (e) {}
      sock.ev.removeAllListeners();
      let i = global.conns.indexOf(sock);
      if (i < 0) return;
      delete global.conns[i];
      global.conns.splice(i, 1);
    }
  }, 60000);
}

// Utilidad básica
function msToTime(duration) {
  var milliseconds = parseInt((duration % 1000) / 100),
    seconds = Math.floor((duration / 1000) % 60),
    minutes = Math.floor((duration / (1000 * 60)) % 60);
  minutes = (minutes < 10) ? '0' + minutes : minutes;
  seconds = (seconds < 10) ? '0' + seconds : seconds;
  return minutes + ' m y ' + seconds + ' s ';
}